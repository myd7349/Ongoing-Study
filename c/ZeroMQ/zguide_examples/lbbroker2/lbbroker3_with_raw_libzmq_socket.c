// 2017-09-01T14:49+08:00
// Rewrite the Load-balancing broker example in:
// https://github.com/booksbyus/zguide/blob/master/examples/C/lbbroker3.c
// with CZMQ 4.x API.


// Q0: Difference between:
//       1. zstr_send("HELLO");
//       2. zframe_new("HELLO", strlen("HELLO"));
//       3. zframe_from("HELLO");
//     does the message generated by these API contains a null terminator or not?
// Answer:
//       1. `zstr_send` sends a string without null terminator, without MORE flag;
//          `zstr_sendm` sends a string without null terminator, with MORE flag;
//       2. zframe_from is implemented as:
//          zframe_t *
//          zframe_from(const char *string)
//          {
//              return zframe_new(string, strlen(string));
//          }
//       So neither of them sends the string with a null terminator.
//

// Q1. Do these czmq API: zstr_send/zstr_recv, zframe_send/zframe_recv, zmsg_send/zmsg_recv
//     work with raw libzmq sockets?
// Short answer: Yes!
// Long story:
// In the history of CZMQ(from CZMQ v1.4 to v4.0.4), there are 3 kind of sockets:
//   1. raw libzmq socket, always wrote as a `void *` (opaque) pointer;
//   2. zsocket_t, which was a part of CZMQ v1.4, and marked as deprecated in CZMQ 3.0; since CZMQ v4.0.3, it was removed from CZMQ;
//   3. zsock_t, which was introduced in CZMQ v3.0;
// zstr_send/zstr_recv, zframe_send/zframe_recv, zmsg_send/zmsg_recv work with all of them.

// Q2: Which type of socket does `zloop_poller` work with?
// Answer:
// `zloop_poller(..., zmq_pollitem_t, ...)` works correctly with `void *` socket(raw libzmq socket) and `zsocket_t`, but not with `zsock_t`.

// Q3: How can I use the `zloop` API when I have a `zsock_t` socket?
// Answer: Hmm. Thers is a `zloop_reader` in `zloop.h`. Give it a try!

// Q4: I saw there is also a `zactor`, what is it for? When should I use it?
// Answer: I DO NOT know yet!

// Q5: Is `zlist` thread-safe?
// Answer: I DO NOT know yet!

#include <pthread.h>

#include "czmq_helpers.h"


#define NBR_CLIENTS 10
#define NBR_WORKERS 3
#define WORKER_READY   "READY"      //  Signals worker is ready


// Basic request-reply client using REQ socket
//
static void *
client_task(void *args)
{
    void *ctx = zmq_ctx_new();
    void *client = zmq_socket(ctx, ZMQ_REQ);

#if (defined (WIN32))
    zmq_connect(client, "tcp://localhost:5672");
#else
    zmq_connect(client, "ipc://frontend.ipc");
#endif

    // Send request, get reply
    zstr_send(client, "HELLO");
    char *reply = zstr_recv(client);
    if (reply) {
        printf("Client: %s\n", reply);
        free(reply);
    }

    zmq_close(client);
    zmq_ctx_term(ctx);

    return NULL;
}


// Worker using REQ socket to do load-balancing
// 
static void *
worker_task(void *args)
{
    void *ctx = zmq_ctx_new();
    void *worker = zmq_socket(ctx, ZMQ_REQ);

#if (defined (WIN32))
    zmq_connect(worker, "tcp://localhost:5673"); // backend
#else
    zmq_connect(worker, "ipc://backend.ipc");
#endif

    // Tell broker we're ready for work
    zstr_send(worker, WORKER_READY);

    // Process messages as they arrive
    while (1) {
        zmsg_t *msg = zmsg_recv(worker);
        if (!msg)
            break;

        if (zmsg_size(msg) == 3) {
            zframe_dump(zmsg_last(msg), "Worker: ", "\n");
            zframe_reset(zmsg_last(msg), "OK", 2);
            zmsg_send(&msg, worker);
        } else {
            assert(false);
        }
    }

    zmq_close(worker);
    zmq_ctx_term(ctx);

    return NULL;
}


// .until
// Our load-balancing structure, passed to reactor handlers
typedef struct {
    void *frontend; // Listen to clients
    void *backend; // Listen to workers
    zlist_t *workers_at_rest; // List of ready workers
} lbbroker_t;


// .split reactor design
// In the reactor design, each time a message arrives on a socket, the
// reactor passes it to a handler function. We have two handlers; one 
// for the frontend, one for the backend:


// Handle input from client, on frontend
int s_handle_frontend(zloop_t *loop, zmq_pollitem_t *poller, void *arg)
{
    lbbroker_t *self = (lbbroker_t *)arg;
    zmsg_t *msg = zmsg_recv(self->frontend);
    if (msg) {
        zmsg_wrap(msg, (zframe_t *)zlist_pop(self->workers_at_rest));
        zmsg_send(&msg, self->backend);

        // Cancel reader on frontend if we went from 1 to 0 workers
        if (zlist_size(self->workers_at_rest) == 0) {
            zmq_pollitem_t poller = { self->frontend, 0, ZMQ_POLLIN };
            zloop_poller_end(loop, &poller);
        }
    }

    return 0;
}


// Handle input from worker, on backend
int s_handle_backend(zloop_t *loop, zmq_pollitem_t *poller, void *arg)
{
    // Use worker identity for load-balancing
    lbbroker_t *self = (lbbroker_t *)arg;
    zmsg_t *msg = zmsg_recv(self->backend);
    if (msg) {
        zframe_t *identity = zmsg_unwrap(msg);
        zlist_append(self->workers_at_rest, identity);

        // Enable reader on frontend if we went from 0 to 1 workers
        if (zlist_size(self->workers_at_rest) == 1) {
            zmq_pollitem_t poller = { self->frontend, 0, ZMQ_POLLIN };
            zloop_poller(loop, &poller, s_handle_frontend, self);
        }

        // Forward message to client if it's not a READY
        zframe_t *frame = zmsg_first(msg);
        if (zframe_streq(frame, WORKER_READY)) {
            zmsg_destroy(&msg);
        } else {
            zmsg_send(&msg, self->frontend);
        }
    }

    return 0;
}


// .split main task
// And the main task now sets up child tasks, then starts its reactor.
// If you press Ctrl-C, the reactor exits and the main task shuts down.
// Because the reactor is a CZMQ class, this example may not translate
// into all languages equally well.

int main(void)
{
    int rc = 0;

    void *ctx = zmq_ctx_new();

    lbbroker_t *self = (lbbroker_t *)zmalloc(sizeof(lbbroker_t));
    self->frontend = zmq_socket(ctx, ZMQ_ROUTER);
    self->backend = zmq_socket(ctx, ZMQ_ROUTER);

#if (defined (WIN32))
    zmq_bind(self->frontend, "tcp://*:5672"); // frontend
    zmq_bind(self->backend, "tcp://*:5673"); // backend
#else
    zmq_bind(self->frontend, "ipc://frontend.ipc");
    zmq_bind(self->backend, "ipc://backend.ipc");
#endif

    int client_nbr;
    for (client_nbr = 0; client_nbr < NBR_CLIENTS; client_nbr++) {
        pthread_t client;
        pthread_create(&client, NULL, client_task, NULL);
        //zthread_new(client_task, NULL);
    }

    int worker_nbr;
    for (worker_nbr = 0; worker_nbr < NBR_WORKERS; worker_nbr++) {
        pthread_t worker;
        pthread_create(&worker, NULL, worker_task, NULL);
        //zthread_new(worker_task, NULL);
    }

    // Queue of available workers
    self->workers_at_rest = zlist_new();

    // Prepare reactor and fire it up
    zloop_t *reactor = zloop_new();
    zmq_pollitem_t poller = { self->backend, 0, ZMQ_POLLIN };
    rc = zloop_poller(reactor, &poller, s_handle_backend, self);
    assert(rc == 0);
    zloop_start(reactor);
    zloop_destroy(&reactor);

    // When we're done, clean up properly
    while (zlist_size(self->workers_at_rest)) {
        zframe_t *frame = (zframe_t *)zlist_pop(self->workers_at_rest);
        zframe_destroy(&frame);
    }
    zlist_destroy(&self->workers_at_rest);

    zmq_close(self->frontend);
    zmq_close(self->backend);
    zmq_ctx_destroy(ctx);

    free(self);

    return 0;
}
